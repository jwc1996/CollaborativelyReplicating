import os, sys, random
import matplotlib.pyplot as plt
import math
import numpy as np
import pylab as plt

# the path of the vehicles
all_path = []
# the actual path for each slot
all_slot = []
# the placement of the original chunks in RSUs
all_placement = []

# The number of chunks of the file
m = 5000

# The number of RSUs in our network
number_rsu = 5000

# The capacity of RSU depicted with chunks
B = 100

# The number of vehicles
v_number = 200

# the value of rho
rho = 4

# The overall versions of the file
v = 7

# bitrate versions, Mbps
bitrate_options = [1, 0.8, 0.7, 0.6, 0.4, 0.3, 0.2]

# the chunk sizes for each vehicle is different with different bitrates
chunk_sizes = []
for k in range(v_number):
    chunk_sizes.append(1000 * bitrate_options[random.randint(0, v - 1)])

# The replication of encoded chunks, need to be modified below
w = 12

# The chunks of the original file, need to be modified below
l = 52

# The bitmap to represent the missing/downloaded chunks
m_bit = [0] * m

for i in range(v_number):
    all_slot.append([])

# simulation times
times = 100


# The communication channel follows Rayleigh distribution.
def generateRayLeigh():
    mean_r = 1000
    mode = mean_r / 1.253

    # e_value = int(np.random.exponential(mode) / 100) * 100
    e_value = int(np.random.rayleigh(mode) / 100) * 100
    if e_value < 500 or e_value > 1500:
        return generateRayLeigh()

    # print(e_value)
    return e_value


# The sojourn time of each vehicle with any RSU obeys exponential distribution
def generateExponential():
    target = 1.0 / 20
    beta = 20
    e_value = np.random.exponential(beta)
    e_value = int(e_value)
    if e_value == 0:
        return generateExponential()
    # print(e_value)
    return e_value


# test above two function
def DistributionTest():
    generateRayLeigh()
    generateExponential()


# read the trace(path) generated by GenerateTrace.py
def ReadPath():
    with open("path_5000.csv", 'r') as f:
        for i in range(v_number):
            line = f.readline()
            temp_segments = [int(e) for e in line.strip().split(',')]
            all_path.append(temp_segments)


# extent the time slot of the path
def ExtendSlot():
    for i in range(v_number):
        for l in range(len(all_path[i])):
            path_index = all_path[i][l]
            temp_time = generateExponential()
            # print(temp_time)
            for k in range(temp_time):
                all_slot[i].append(path_index)


# randomly initialize the original chunks to each rsu
def RandomOriginalPlacement():
    for j in range(number_rsu):
        o_temp = set()
        count = 0
        while count < l:
            value = random.randint(0, m - 1)
            if value not in o_temp:
                count = count + 1
                o_temp.add(value)
        all_placement.append(list(o_temp))


# trace based simulation
def RunEntrance():
    download_time = []
    for i in range(times):
        print("times:", i)
        # initialization
        finished_download_time = []

        # previous rsu
        pre_rsu = [-1 for k in range(v_number)]

        # finished chunks
        number_finish_chunk = [0 for k in range(v_number)]

        # whether the vehicle is finished
        is_vehicle_finished = [0] * v_number

        # whether the chunk is downloaded, for each vehicle
        is_bit_all = []

        for j in range(v_number):
            m_bit = [0] * m
            is_bit_all.append(m_bit)

        # accumulated size of current chunk
        size_already = [0 for k in range(v_number)]

        # limited the encoded chunks for v-rsu
        encoded_chunks_limited = []
        for k in range(v_number):
            temp_test = [0] * number_rsu
            encoded_chunks_limited.append(temp_test)

        # run
        for j in range(200000):
            finished_number = sum(is_vehicle_finished)

            if finished_number == v_number:
                break

            current_rsu = [all_slot[k][j] for k in range(v_number)]

            temp_rsu = {}

            for k in range(v_number):
                if is_vehicle_finished[k] == 1:
                    continue

                if current_rsu[k] not in temp_rsu:
                    temp_rsu[current_rsu[k]] = 1
                else:
                    if temp_rsu[current_rsu[k]] < 5:
                        temp_rsu[current_rsu[k]] = temp_rsu[current_rsu[k]] + 1

            speed_rsu = {}
            served_number_rsu = {}
            for key in temp_rsu:
                speed_rsu[key] = generateRayLeigh()
                served_number_rsu[key] = 0

            for k in range(v_number):
                if is_vehicle_finished[k] == 1:
                    continue

                if current_rsu[k] != pre_rsu[k]:
                    size_already[k] = 0

                if served_number_rsu[current_rsu[k]] < 5:
                    size_already[k] = size_already[k] + speed_rsu[current_rsu[k]] * 1.0 / temp_rsu[current_rsu[k]]
                else:
                    continue

                while size_already[k] >= chunk_sizes[k]:
                    if is_vehicle_finished[k] == 1:
                        break

                    flag = False

                    # try to obtain original chunks
                    for z in range(l):
                        if is_bit_all[k][all_placement[current_rsu[k]][z]] == 0:
                            is_bit_all[k][all_placement[current_rsu[k]][z]] = 1
                            size_already[k] = size_already[k] - chunk_sizes[k]
                            number_finish_chunk[k] = number_finish_chunk[k] + 1
                            if number_finish_chunk[k] >= m:
                                is_vehicle_finished[k] = 1
                                finished_download_time.append(j)

                            flag = True

                            break

                    if flag == True:
                        continue

                    # try to obtain encoded chunks
                    if encoded_chunks_limited[k][current_rsu[k]] < w:
                        encoded_chunks_limited[k][current_rsu[k]] = encoded_chunks_limited[k][current_rsu[k]] + 1
                        size_already[k] = size_already[k] - chunk_sizes[k]
                        number_finish_chunk[k] = number_finish_chunk[k] + 1
                        if number_finish_chunk[k] >= m:
                            is_vehicle_finished[k] = 1
                            finished_download_time.append(j)
                        flag = True

                    if flag == True:
                        continue

                    if flag == False:
                        break

            pre_rsu = current_rsu

        # add the value
        download_time.append(sum(finished_download_time) / v_number)

    average_download_time = sum(download_time) / times

    print("average_download_time", average_download_time)
    return int(average_download_time)


if __name__ == "__main__":
    # simulation times
    times = 100

    # read the trace(path) generated by GenerateTrace.py, need to be generated first
    ReadPath()

    # extent the time slot of the path
    ExtendSlot()

    # for encoded strategy
    print("encoded strategy:")
    writelines = []
    for i in range(11):
        print("redundancy_rate: ", 0.01 * i)
        m = 5000
        w = int(100 / rho)
        l = 0

        redundancy_rate = 0.01 * i

        m = int(m + m * redundancy_rate)

        all_placement = []
        # randomly initialize the original chunks to each rsu
        RandomOriginalPlacement()
        writelines.append(str(int(RunEntrance())))
    # save result
    with open('redundancy_downloading_time.csv', 'a+', newline='') as f_e:
        f_e.write(','.join(writelines) + '\r\n')

    # for original strategy
    print("original strategy:")
    writelines = []
    for i in range(11):
        print("redundancy_rate: ", 0.01 * i)
        w = 0
        l = 100

        # for original strategy, there is no redundancy, so m is always equals to 5000
        m = 5000

        all_placement = []
        # randomly initialize the original chunks to each rsu
        RandomOriginalPlacement()
        writelines.append(str(RunEntrance()))
    with open('redundancy_downloading_time.csv', 'a+', newline='') as f_e:
        f_e.write(','.join(writelines) + '\r\n')

    # for mixed strategy
    writelines = []
    print("mixed strategy:")
    for i in range(11):
        print("redundancy_rate: ", 0.01 * i)
        m = 5000
        # w and l are determined by the ISP algorithm, same as simulation_trace_based.py, rho = 4
        w = 12
        l = 52

        redundancy_rate = 0.01 * i

        m = int(m + m * redundancy_rate)

        all_placement = []
        # randomly initialize the original chunks to each rsu
        RandomOriginalPlacement()
        writelines.append(str(RunEntrance()))
    with open('redundancy_downloading_time.csv', 'a+', newline='') as f_e:
        f_e.write(','.join(writelines) + '\r\n')
