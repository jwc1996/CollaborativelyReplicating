import os, sys, random
import matplotlib.pyplot as plt
import math
import numpy as np
import pylab as plt

# the path of the vehicles
all_path = []
# the actual path for each slot
all_slot = []
# the placement of the original chunks in RSUs
all_placement = []

# The number of chunks of the file
m = 5000

# The number of RSUs in our network
number_rsu = 5000

# The capacity of RSU depicted with chunks
B = 100

# The overall versions of the file, need to be modified below
v = 3

# The replication of encoded chunks, need to be modified below
w = 32

# The chunks of the original file, need to be modified below
l = 36

# The number of vehicles
v_number = 200

# the chunk sizes for each vehicle is different with different bitrates
chunk_sizes = []

# bitrate versions
bitrate_options = []

# The bitmap to represent the missing/downloaded chunks
m_bit = [0] * m

for i in range(v_number):
    all_slot.append([])

# simulation times
times = 100


# generate bitrate distribution randomly according to the value of rho, and update the chunk_sizes
def generate_bitrate_randomly(rho=2):
    v = 2 * rho - 1
    bitrate_options.append(1)  # bitrate_options[0] is 1Mbps
    upper_sum = rho * bitrate_options[0] - bitrate_options[0]
    encoded_versions = [random.uniform(0.01, 1) for _ in range(v - 1)]
    sum_encoded = sum(encoded_versions)
    k = upper_sum / sum_encoded
    for rate in encoded_versions:
        bitrate_options.append(round(rate * k, 2))
    print("rho: {}, sum of bitrates: {}".format(rho, sum(bitrate_options)))
    print(bitrate_options)

    # update the chunk sizes for each vehicle
    for k in range(v_number):
        chunk_sizes.append(1000 * bitrate_options[random.randint(0, v - 1)])
    # print(chunk_sizes)


# The communication channel follows Rayleigh distribution.
def generateRayLeigh():
    mean_r = 1000
    mode = mean_r / 1.253

    # e_value = int(np.random.exponential(mode) / 100) * 100
    e_value = int(np.random.rayleigh(mode) / 100) * 100
    if e_value < 500 or e_value > 1500:
        return generateRayLeigh()

    # print(e_value)
    return e_value


# The sojourn time of each vehicle with any RSU obeys exponential distribution
def generateExponential():
    target = 1.0 / 20
    beta = 20
    e_value = np.random.exponential(beta)
    e_value = int(e_value)
    if e_value == 0:
        return generateExponential()
    # print(e_value)
    return e_value


# test above two function
def DistributionTest():
    generateRayLeigh()
    generateExponential()


# read the trace(path) generated by GenerateTrace.py
def ReadPath():
    with open("path_5000.csv", 'r') as f:
        for i in range(v_number):
            line = f.readline()
            temp_segments = [int(e) for e in line.strip().split(',')]
            all_path.append(temp_segments)


# extent the time slot of the path
def ExtendSlot():
    for i in range(v_number):
        for l in range(len(all_path[i])):
            path_index = all_path[i][l]
            temp_time = generateExponential()
            # print(temp_time)
            for k in range(temp_time):
                all_slot[i].append(path_index)


# randomly initialize the original chunks to each rsu
def RandomOriginalPlacement():
    for j in range(number_rsu):
        o_temp = set()
        count = 0
        while count < l:
            value = random.randint(0, m - 1)
            if value not in o_temp:
                count = count + 1
                o_temp.add(value)
        all_placement.append(list(o_temp))


# trace based simulation
def RunEntrance():
    download_time = []
    for i in range(times):
        print("times:", i)
        # initialization
        finished_download_time = []

        # previous rsu
        pre_rsu = [-1 for k in range(v_number)]

        # finished chunks
        number_finish_chunk = [0 for k in range(v_number)]

        # whether the vehicle is finished
        is_vehicle_finished = [0] * v_number

        # whether the chunk is downloaded, for each vehicle
        is_bit_all = []

        for j in range(v_number):
            m_bit = [0] * m
            is_bit_all.append(m_bit)

        # accumulated size of current chunk
        size_already = [0 for k in range(v_number)]

        # limited the encoded chunks for v-rsu
        encoded_chunks_limited = []
        for k in range(v_number):
            temp_test = [0] * number_rsu
            encoded_chunks_limited.append(temp_test)

        # run
        for j in range(200000):
            finished_number = sum(is_vehicle_finished)

            if finished_number == v_number:
                break

            current_rsu = [all_slot[k][j] for k in range(v_number)]

            temp_rsu = {}

            for k in range(v_number):
                if is_vehicle_finished[k] == 1:
                    continue

                if current_rsu[k] not in temp_rsu:
                    temp_rsu[current_rsu[k]] = 1
                else:
                    if temp_rsu[current_rsu[k]] < 5:
                        temp_rsu[current_rsu[k]] = temp_rsu[current_rsu[k]] + 1

            speed_rsu = {}
            served_number_rsu = {}
            for key in temp_rsu:
                speed_rsu[key] = generateRayLeigh()
                served_number_rsu[key] = 0

            for k in range(v_number):
                if is_vehicle_finished[k] == 1:
                    continue

                if current_rsu[k] != pre_rsu[k]:
                    size_already[k] = 0

                if served_number_rsu[current_rsu[k]] < 5:
                    size_already[k] = size_already[k] + speed_rsu[current_rsu[k]] * 1.0 / temp_rsu[current_rsu[k]]
                else:
                    continue

                while size_already[k] >= chunk_sizes[k]:
                    if is_vehicle_finished[k] == 1:
                        break

                    flag = False

                    # try to obtain original chunks
                    for z in range(l):
                        if is_bit_all[k][all_placement[current_rsu[k]][z]] == 0:
                            is_bit_all[k][all_placement[current_rsu[k]][z]] = 1
                            size_already[k] = size_already[k] - chunk_sizes[k]
                            number_finish_chunk[k] = number_finish_chunk[k] + 1
                            if number_finish_chunk[k] >= m:
                                is_vehicle_finished[k] = 1
                                finished_download_time.append(j)

                            flag = True

                            break

                    if flag == True:
                        continue

                    # try to obtain encoded chunks
                    if encoded_chunks_limited[k][current_rsu[k]] < w:
                        encoded_chunks_limited[k][current_rsu[k]] = encoded_chunks_limited[k][current_rsu[k]] + 1
                        size_already[k] = size_already[k] - chunk_sizes[k]
                        number_finish_chunk[k] = number_finish_chunk[k] + 1
                        if number_finish_chunk[k] >= m:
                            is_vehicle_finished[k] = 1
                            finished_download_time.append(j)
                        flag = True

                    if flag == True:
                        continue

                    if flag == False:
                        break

            pre_rsu = current_rsu

        # add the value
        download_time.append(sum(finished_download_time) / v_number)

    average_download_time = sum(download_time) / times

    print("average_download_time", average_download_time)
    return int(average_download_time)


if __name__ == "__main__":
    # simulation times
    times = 100

    # read the trace(path) generated by GenerateTrace.py, need to be generated first
    ReadPath()

    # extent the time slot of the path
    ExtendSlot()

    # for mixed strategy, w and l are determined by the ISP algorithm, with expected d is 40 (average)
    l_set = [36, 43, 52, 55, 58, 58, 60, 64, 60]
    w_set = [32, 19, 12, 9, 7, 6, 5, 4, 4]

    result_download_time = []
    # the values of rho in [2, 10]
    for index in range(2, 11):
        # for mixed strategy
        w = w_set[index - 2]
        l = l_set[index - 2]

        # for original strategy
        # w = 0
        # l = 100

        # for encoded strategy
        # w = int(100 / index)
        # l = 0

        chunk_sizes = []
        bitrate_options = []

        # generate bitrate distribution randomly according to the value of rho, and update the chunk_sizes
        generate_bitrate_randomly(rho=index)

        all_placement = []
        # randomly initialize the original chunks to each rsu
        RandomOriginalPlacement()

        # trace based simulation
        result_download_time.append(RunEntrance())
    print(result_download_time)

