import os, sys, random
import matplotlib.pyplot as plt
import math
import numpy as np
import pylab as plt

# the path of the vehicles
all_path = []
# the actual path for each slot
all_slot = []
# the placement of the original chunks in RSUs
all_placement = []

# The number of chunks of the file
m = 5000

# The number of chunks for a segment
segment_size = 500

# The number of RSUs in our network
number_rsu = 5000

# The capacity of RSU depicted with chunks
B = 100

# The number of vehicles
v_number = 200

# the value of rho
rho = 3

# The overall versions of the file
v = 5

# bitrate versions, Mbps
bitrate_options = [1, 0.8, 0.6, 0.4, 0.2]

# the chunk sizes for each vehicle is different with different bitrates
chunk_sizes = []
for k in range(v_number):
    chunk_sizes.append(1000 * bitrate_options[random.randint(0, v - 1)])

# playback time for a segment, 300s, can be adjust
playback_time = 300

# The replication of encoded chunks, need to be modified below
w = 2

# The chunks of the original file, need to be modified below
l = 4

# The bitmap to represent the missing/downloaded chunks
m_bit = [0] * m

for i in range(v_number):
    all_slot.append([])

# simulation times
times = 100


# The communication channel follows Rayleigh distribution.
def generateRayLeigh():
    mean_r = 1000
    mode = mean_r / 1.253

    # e_value = int(np.random.exponential(mode) / 100) * 100
    e_value = int(np.random.rayleigh(mode) / 100) * 100
    if e_value < 500 or e_value > 1500:
        return generateRayLeigh()

    # print(e_value)
    return e_value


# The sojourn time of each vehicle with any RSU obeys exponential distribution
def generateExponential():
    target = 1.0 / 20
    beta = 20
    e_value = np.random.exponential(beta)
    e_value = int(e_value)
    if e_value == 0:
        return generateExponential()
    # print(e_value)
    return e_value


# test above two function
def DistributionTest():
    generateRayLeigh()
    generateExponential()


# read the trace(path) generated by GenerateTrace.py
def ReadPath():
    with open("path_5000.csv", 'r') as f:
        for i in range(v_number):
            line = f.readline()
            temp_segments = [int(e) for e in line.strip().split(',')]
            all_path.append(temp_segments)


# extent the time slot of the path
def ExtendSlot():
    for i in range(v_number):
        for l in range(len(all_path[i])):
            path_index = all_path[i][l]
            temp_time = generateExponential()
            # print(temp_time)
            for k in range(temp_time):
                all_slot[i].append(path_index)


# randomly initialize the original chunks to each rsu, different from before
def RandomOriginalPlacement():
    for j in range(number_rsu):
        o_temp = set()
        # each segment is regarded as an independent file, according to the sequence
        for segment_start in range(0, m, segment_size):
            count = 0
            while count < l:
                value = random.randint(segment_start, segment_start + segment_size - 1)
                if value not in o_temp:
                    count = count + 1
                    o_temp.add(value)
        o_temp = list(o_temp)
        # o_temp.sort()
        # print(o_temp)
        all_placement.append(o_temp)


# trace based simulation
def RunEntrance(start_delay):
    server_bandwidth = []
    print("start_delay: {}".format(start_delay))
    for i in range(times):
        print("times: ", i)

        # bandwidth each vehicle
        consumed_server_bandwidth = [0 for k in range(v_number)]

        # initialization
        finished_download_time = []

        # previous rsu
        pre_rsu = [-1 for k in range(v_number)]

        # finished chunks
        number_finish_chunk = [0 for k in range(v_number)]

        # whether the vehicle is finished
        is_vehicle_finished = [0] * v_number

        # whether the chunk is downloaded, for each vehicle
        is_bit_all = []

        for j in range(v_number):
            m_bit = [0] * m
            is_bit_all.append(m_bit)

        # accumulated size of current chunk
        size_already = [0 for k in range(v_number)]

        # limited the encoded chunks for v-rsu
        encoded_chunks_limited = []
        for k in range(v_number):
            temp_test = [0] * number_rsu
            encoded_chunks_limited.append(temp_test)

        finished_segment_count = 0

        # record the number of encoded chunks downloaded by each vehicle
        w_count = [0 for k in range(v_number)]

        # run
        for j in range(200000):
            finished_number = sum(is_vehicle_finished)

            if finished_number == v_number:
                break

            if finished_segment_count == 10:
                break

            current_rsu = [all_slot[k][j] for k in range(v_number)]

            temp_rsu = {}

            for k in range(v_number):
                if is_vehicle_finished[k] == 1:
                    continue

                if current_rsu[k] not in temp_rsu:
                    temp_rsu[current_rsu[k]] = 1
                else:
                    if temp_rsu[current_rsu[k]] < 5:
                        temp_rsu[current_rsu[k]] = temp_rsu[current_rsu[k]] + 1

            speed_rsu = {}
            served_number_rsu = {}
            for key in temp_rsu:
                speed_rsu[key] = generateRayLeigh()
                served_number_rsu[key] = 0

            for k in range(v_number):
                if is_vehicle_finished[k] == 1:
                    continue

                if current_rsu[k] != pre_rsu[k]:
                    size_already[k] = 0

                if served_number_rsu[current_rsu[k]] < 5:
                    size_already[k] = size_already[k] + speed_rsu[current_rsu[k]] * 1.0 / temp_rsu[current_rsu[k]]
                else:
                    continue

                while size_already[k] >= chunk_sizes[k]:
                    if is_vehicle_finished[k] == 1:
                        break

                    flag = False

                    # try to obtain original chunks
                    for z in range(l*10):
                        if is_bit_all[k][all_placement[current_rsu[k]][z]] == 0:
                            is_bit_all[k][all_placement[current_rsu[k]][z]] = 1
                            size_already[k] = size_already[k] - chunk_sizes[k]
                            number_finish_chunk[k] = number_finish_chunk[k] + 1
                            if number_finish_chunk[k] >= m:
                                is_vehicle_finished[k] = 1
                                finished_download_time.append(j)

                            flag = True

                            break

                    if flag == True:
                        continue

                    # try to obtain encoded chunks
                    if encoded_chunks_limited[k][current_rsu[k]] < w*10:
                        encoded_chunks_limited[k][current_rsu[k]] = encoded_chunks_limited[k][current_rsu[k]] + 1
                        size_already[k] = size_already[k] - chunk_sizes[k]
                        number_finish_chunk[k] = number_finish_chunk[k] + 1
                        w_count[k] += 1
                        if number_finish_chunk[k] >= m:
                            is_vehicle_finished[k] = 1
                            finished_download_time.append(j)
                        flag = True

                    if flag == True:
                        continue

                    if flag == False:
                        break

            pre_rsu = current_rsu

            # calculate the bandwidth
            if j == start_delay - 1 or ((j - start_delay + 1) % playback_time == 0 and j > start_delay):
                for k in range(v_number):
                    segment_start = finished_segment_count * segment_size
                    # original chunks
                    for c in range(segment_start, segment_start + segment_size):
                        if is_bit_all[k][c] != 1:
                            consumed_server_bandwidth[k] += chunk_sizes[k]
                            is_bit_all[k][c] = 1

                    # encoded chunks
                    consumed_server_bandwidth[k] = consumed_server_bandwidth[k] - w_count[k] * chunk_sizes[k]
                w_count = [0 for k in range(v_number)]
                finished_segment_count += 1

            # if j == start_delay - 1:
            #     print(number_finish_chunk)

        # add the value
        server_bandwidth.append(sum(consumed_server_bandwidth) / v_number)

    average_server_bandwidth = sum(server_bandwidth) / times / 1000

    print("average_server_bandwidth: {}Mb".format(average_server_bandwidth))
    return round(average_server_bandwidth, 2)


if __name__ == "__main__":
    # simulation times
    times = 100

    # read the trace(path) generated by GenerateTrace.py, need to be generated first
    ReadPath()

    # extent the time slot of the path
    ExtendSlot()

    writelines = []
    for i in range(40, 201, 40):
        # for mixed strategy
        w = 2
        l = 4

        # for encoded strategy
        # w = int(10 / rho)
        # l = 0

        # for original strategy
        # w = 0
        # l = 10

        all_placement = []
        # randomly initialize the original chunks to each rsu, different from before
        RandomOriginalPlacement()
        writelines.append(str(RunEntrance(i)))
    # save result
    with open('streaming_bandwidth.csv', 'a+', newline='') as f_e:
        f_e.write(','.join(writelines) + '\r\n')
